---
import { Icon } from "astro-icon/components";

interface Props {
  messagesCount: number;
}

const { messagesCount } = Astro.props;
---

<div
  data-messages-count={messagesCount}
  id="tool-bar"
  class="fixed right-40 top-0 transform -translate-y-full flex bg-stone-800 opacity-10 rounded-xl px-16 text-white font-aside text-xs hover:opacity-100 z-50 transition-all"
>
  <button id="previous-button" class="w-80 border-r border-stone-700 py-8">
    <div class="flex flex-col justify-between">
      <p class="self-start uppercase">Previous</p>
      <Icon name="arrow-left" class="size-20" />
    </div>
  </button>
  <button class="px-16 py-8 border-r border-stone-700"
    ><Icon name="camera" class="size-20" />
  </button>
  <button class="px-16 py-8 border-r border-stone-700"
    ><Icon name="expand" class="size-20" />
  </button>
  <button id="next-button" class="w-80 py-8">
    <div class="flex flex-col justify-between">
      <p class="self-end uppercase">Next</p>
      <Icon name="arrow-right" class="size-20 self-end" />
    </div>
  </button>
</div>

<style>
  .toolbar-shown {
    transform: translateY(50%);
  }
</style>

<script>
  import { $currentExhibitIdx } from "../currentExhibitIdx";

  const toolBar = document.getElementById("tool-bar");
  const messagesCount = toolBar?.dataset.messagesCount;

  // Observation for Intro
  const introObserverCallback = (entries: IntersectionObserverEntry[]) => {
    if (toolBar) {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          toolBar.classList.remove("toolbar-shown");
        } else {
          toolBar.classList.add("toolbar-shown");
        }
      });
    }
  };
  const introObserver = new IntersectionObserver(introObserverCallback, {
    threshold: 0.5,
  });
  const introTarget = document.getElementById("intro");
  if (introTarget) {
    introObserver.observe(introTarget);
  }

  // Observation for Exhibits
  const exhibitTargets = [
    ...Array(parseInt(messagesCount ? messagesCount : "0")).keys(),
  ].map((idx) => {
    return document.getElementById(`exhibit-${idx}`);
  });
  const exhibitObserverCallback = (entries: IntersectionObserverEntry[]) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        // console.log(entry.target.id);
        $currentExhibitIdx.set(parseInt(entry.target.id.slice(8)));
      }
    });
  };
  const exhibitObserver = new IntersectionObserver(exhibitObserverCallback, {
    threshold: 0.5,
  });
  exhibitTargets.forEach((target) => {
    if (target) {
      exhibitObserver.observe(target);
    }
  });

  // Add event listeners for previous and next buttons based on observation state
  const previousButton = document.getElementById("previous-button");
  const nextButton = document.getElementById("next-button");
  previousButton?.addEventListener("click", () => {
    const currentExhibitIdx = $currentExhibitIdx.get();

    if (currentExhibitIdx === 0) {
      introTarget?.scrollIntoView({ behavior: "smooth" });
    } else {
      exhibitTargets[currentExhibitIdx - 1]?.scrollIntoView({
        behavior: "smooth",
      });
    }
  });
  nextButton?.addEventListener("click", () => {
    exhibitTargets[$currentExhibitIdx.get() + 1]?.scrollIntoView({
      behavior: "smooth",
    });
  });
</script>
